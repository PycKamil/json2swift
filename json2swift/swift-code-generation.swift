//
//  swift-code-generation.swift
//  json2swift
//
//  Created by Joshua Smith on 10/14/16.
//  Copyright Â© 2016 iJoshSmith. All rights reserved.
//

import Foundation

struct SwiftCodeGenerator {
    /// This method is used when multiple Swift files are being generated.
    static func generateCode(for swiftStruct: SwiftStruct) -> String {
        return [
            preamble,
            swiftStruct.toSwiftCode(),
            ""].joined(separator: "\n")
    }

    private static let preamble = [
        "// This file was generated by json2swift. https://github.com/pyckamil/json2swift",
        "",
        "import Foundation",
        "import Unbox",
        ""].joined(separator: "\n")
}


// MARK: - Implementation

typealias SwiftCode = String
typealias LineOfCode = SwiftCode

fileprivate struct Indentation {
    private let chars: String
    private let level: Int
    private let value: String

    init(chars: String, level: Int = 0) {
        precondition(level >= 0)
        self.chars = chars
        self.level = level
        self.value = String(repeating: chars, count: level)
    }

    func apply(toLineOfCode lineOfCode: LineOfCode) -> LineOfCode {
        return value + lineOfCode
    }

    func apply(toFirstLine firstLine: LineOfCode,
               nestedLines generateNestedLines: (Indentation) -> [LineOfCode],
               andLastLine lastLine: LineOfCode?) -> [LineOfCode] {
        let first  = apply(toLineOfCode: firstLine)
        let middle = generateNestedLines(self.increased())
        var returnValue = [first] + middle
        if let lastLine = lastLine {
            let last   = apply(toLineOfCode: lastLine)
            returnValue += [last]
        }
        return returnValue
    }

    private func increased() -> Indentation {
        return Indentation(chars: chars, level: level + 1)
    }
}

fileprivate extension SwiftStruct {
    func toSwiftCode(indentedBy indentChars: String = "    ") -> SwiftCode {
        let indentation = Indentation(chars: indentChars)
        let linesOfCode = toLinesOfCode(at: indentation)
            + toExtenstionLinesOfCode(at: indentation)
            + toEqualLinesOfCode(at: indentation)
            + toSerializableExtension(at: indentation)
        return linesOfCode.joined(separator: "\n")
    }

    private func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "public struct \(name): Equatable {",
            nestedLines:      linesOfCodeForMembers(at:),
            andLastLine: "}")
    }

    private func toExtenstionLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "\nextension \(name): Unboxable {",
            nestedLines:       failableInitializer.toLinesOfCode(at:),
            andLastLine: "}")
    }

    private func toEqualLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(toFirstLine: "\npublic func == (lhs: \(name), rhs: \(name)) -> Bool {",
                                 nestedLines: linesOfCodeForComparing(at:),
                                 andLastLine: "}")
    }

    private func toSerializableExtension(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "\nextension \(name): Serializable {",
            nestedLines:       serializable.toLinesOfCode(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        return linesOfCodeForProperties(at: indentation)
            + initializer.toLinesOfCode(at: indentation)
    }

    private func linesOfCodeForProperties(at indentation: Indentation) -> [LineOfCode] {
        return sorted(properties: properties).map { property in
            let propertyCode = property.toLineOfCode()
            return indentation.apply(toLineOfCode: propertyCode)
        }
    }

    private func linesOfCodeForComparing(at indentation: Indentation) -> [LineOfCode] {
        return comparator.toLinesOfCode(at: indentation)
    }

    private var sortedNestedStructs: [SwiftStruct] {
        return nestedStructs.sorted(by: { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        })
    }
}

fileprivate extension SwiftType {
    func toSwiftCode() -> SwiftCode {
        return isOptional ? name + "?" : name
    }
}

fileprivate extension SwiftProperty {
    func toLineOfCode() -> LineOfCode {
        return "public let \(name): \(type.toSwiftCode())"
    }

    func toComparingLineOfCode(isFirstProperty: Bool) -> LineOfCode {
        let line = "lhs.\(name) == rhs.\(name)"
        if isFirstProperty {
            return line
        }
        return "&& " + line
    }
}

fileprivate extension SwiftParameter {
    func toSwiftCode() -> SwiftCode {
        return "\(name): \(type.toSwiftCode())"
    }
}

fileprivate extension SwiftComparator {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "return",
            nestedLines:  linesOfCodeForComparing(at:),
            andLastLine: nil)
    }

    func linesOfCodeForComparing(at indentation: Indentation) -> [LineOfCode] {
        return sorted(properties: properties).enumerated().map { (index, property) in
            let propertyCode = property.toComparingLineOfCode(isFirstProperty: index == 0)
            return indentation.apply(toLineOfCode: propertyCode)
        }
    }
}

func sorted(properties: [SwiftProperty]) -> [SwiftProperty] {
    return properties.sorted { (lhs, rhs) -> Bool in
        return lhs.name.compare(rhs.name) == .orderedAscending
    }
}

fileprivate extension Serializable {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "func serialize() -> Any {",
            nestedLines:  linesOfSerialization(at:),
            andLastLine: "}")
    }

    func linesOfSerialization(at indentation: Indentation) -> [LineOfCode] {
        let sortedProperties = sorted(properties: properties)
        var lineOfCodes: [LineOfCode] = []
        lineOfCodes.append(indentation.apply(toLineOfCode: "var serializationDictionary: [AnyHashable: Any] = [:]"))
        lineOfCodes.append(contentsOf: sortedProperties.enumerated().map { (index, property) in

            var lineOfCode = ""
            if property.type.isOptional {
                lineOfCode += "if let \(property.name) = \(property.name) { "
                lineOfCode += assignToDictionary(property: property)
                lineOfCode += " }"
            } else {
                lineOfCode += assignToDictionary(property: property)
            }

            return indentation.apply(toLineOfCode: lineOfCode)
        })
        lineOfCodes.append(indentation.apply(toLineOfCode: "return serializationDictionary"))
        return lineOfCodes
    }

    func customPropertyKey(property: SwiftProperty) -> String {
        if let transformation = self.requiredTransformations.filter({ $0.propertyName == property.name }).first {
            return transformation.attributeName
        }
        return property.name
    }

    func assignToDictionary(property: SwiftProperty) -> LineOfCode {
        return "serializationDictionary[\"\(customPropertyKey(property: property))\"] = \(property.name).serialize()"
    }
}

fileprivate extension SwiftInitializer {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "public init(\(parameterList)) {",
            nestedLines:      linesOfCodeForPropertyAssignments(at:),
            andLastLine: "}")
    }

    private var parameterList: SwiftCode {
        return sortedParameters
            .map { $0.toSwiftCode() }
            .joined(separator: ", ")
    }

    private func linesOfCodeForPropertyAssignments(at indentation: Indentation) -> [LineOfCode] {
        return sortedParameters
            .map { "self.\($0.name) = \($0.name)" }
            .map(indentation.apply(toLineOfCode:))
    }

    private var sortedParameters: [SwiftParameter] {
        return parameters.sorted { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        }
    }
}

fileprivate extension SwiftFailableInitializer {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "public init(unboxer: Unboxer) throws {",
            nestedLines:      linesOfCodeInMethodBody(at:),
            andLastLine: "}")
    }

    private func linesOfCodeInMethodBody(at indentation: Indentation) -> [LineOfCode] {
        let linesOfCode = linesOfCodeForTransformations
        return linesOfCode.map(indentation.apply(toLineOfCode:))
    }

    private var linesOfCodeForTransformations: [LineOfCode] {
        let requiredTransformationLines = sortedRequiredTransformations.map { $0.requiredUnboxStatement }
        let optionalTransformationLines = sortedOptionalTransformations.map { $0.optionalUnboxStatement }
        return (requiredTransformationLines + optionalTransformationLines)
    }

    private var sortedRequiredTransformations: [TransformationFromJSON] {
        return sort(transformations: requiredTransformations)
    }

    private var sortedOptionalTransformations: [TransformationFromJSON] {
        return sort(transformations: optionalTransformations)
    }

    private func sort(transformations: [TransformationFromJSON]) -> [TransformationFromJSON] {
        return transformations.sorted { (lhs, rhs) -> Bool in
            return lhs.propertyName.compare(rhs.propertyName) == .orderedAscending
        }
    }
}

// Internal for unit test access.
internal extension TransformationFromJSON {
    var requiredUnboxStatement: LineOfCode {
        return "self.\(propertyName) = try unboxer.unbox(key: \"\(attributeName)\")"
    }

    var optionalUnboxStatement: LineOfCode {
        return "self.\(propertyName) = unboxer.unbox(key: \"\(attributeName)\")"
    }
}
