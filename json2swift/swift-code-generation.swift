//
//  swift-code-generation.swift
//  json2swift
//
//  Created by Joshua Smith on 10/14/16.
//  Copyright Â© 2016 iJoshSmith. All rights reserved.
//

import Foundation

struct SwiftCodeGenerator {
    /// This method is used when multiple Swift files are being generated.
    static func generateCode(for swiftStruct: SwiftStruct) -> String {
        return [
            preamble,
            swiftStruct.toSwiftCode(),
            ""].joined(separator: "\n")
    }

    private static let preamble = [
        "// This file was generated by json2swift. https://github.com/pyckamil/json2swift",
        "",
        "import Foundation",
        "import Unbox",
        ""].joined(separator: "\n")
}


// MARK: - Implementation

typealias SwiftCode = String
typealias LineOfCode = SwiftCode

fileprivate struct Indentation {
    private let chars: String
    private let level: Int
    private let value: String

    init(chars: String, level: Int = 0) {
        precondition(level >= 0)
        self.chars = chars
        self.level = level
        self.value = String(repeating: chars, count: level)
    }

    func apply(toLineOfCode lineOfCode: LineOfCode) -> LineOfCode {
        return value + lineOfCode
    }

    func apply(toFirstLine firstLine: LineOfCode,
               nestedLines generateNestedLines: (Indentation) -> [LineOfCode],
               andLastLine lastLine: LineOfCode) -> [LineOfCode] {
        let first  = apply(toLineOfCode: firstLine)
        let middle = generateNestedLines(self.increased())
        let last   = apply(toLineOfCode: lastLine)
        return [first] + middle + [last]
    }

    private func increased() -> Indentation {
        return Indentation(chars: chars, level: level + 1)
    }
}

fileprivate extension SwiftStruct {
    func toSwiftCode(indentedBy indentChars: String = "    ") -> SwiftCode {
        let indentation = Indentation(chars: indentChars)
        let linesOfCode = toLinesOfCode(at: indentation) + toExtenstionLinesOfCode(at: indentation)
        return linesOfCode.joined(separator: "\n")
    }

    private func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "public struct \(name) {",
            nestedLines:      linesOfCodeForMembers(at:),
            andLastLine: "}")
    }

    private func toExtenstionLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "\nextension \(name): Unboxable {",
            nestedLines:       failableInitializer.toLinesOfCode(at:),
            andLastLine: "}")
    }

    private func linesOfCodeForMembers(at indentation: Indentation) -> [LineOfCode] {
        return linesOfCodeForProperties(at: indentation)
            + initializer.toLinesOfCode(at: indentation)
    }

    private func linesOfCodeForProperties(at indentation: Indentation) -> [LineOfCode] {
        return sortedProperties.map { property in
            let propertyCode = property.toLineOfCode()
            return indentation.apply(toLineOfCode: propertyCode)
        }
    }

    private var sortedProperties: [SwiftProperty] {
        return properties.sorted { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        }
    }

    private var sortedNestedStructs: [SwiftStruct] {
        return nestedStructs.sorted(by: { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        })
    }
}

fileprivate extension SwiftType {
    func toSwiftCode() -> SwiftCode {
        return isOptional ? name + "?" : name
    }
}

fileprivate extension SwiftProperty {
    func toLineOfCode() -> LineOfCode {
        return "public let \(name): \(type.toSwiftCode())"
    }
}

fileprivate extension SwiftParameter {
    func toSwiftCode() -> SwiftCode {
        return "\(name): \(type.toSwiftCode())"
    }
}

fileprivate extension SwiftInitializer {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "public init(\(parameterList)) {",
            nestedLines:      linesOfCodeForPropertyAssignments(at:),
            andLastLine: "}")
    }

    private var parameterList: SwiftCode {
        return sortedParameters
            .map { $0.toSwiftCode() }
            .joined(separator: ", ")
    }

    private func linesOfCodeForPropertyAssignments(at indentation: Indentation) -> [LineOfCode] {
        return sortedParameters
            .map { "self.\($0.name) = \($0.name)" }
            .map(indentation.apply(toLineOfCode:))
    }

    private var sortedParameters: [SwiftParameter] {
        return parameters.sorted { (lhs, rhs) -> Bool in
            return lhs.name.compare(rhs.name) == .orderedAscending
        }
    }
}

fileprivate extension SwiftFailableInitializer {
    func toLinesOfCode(at indentation: Indentation) -> [LineOfCode] {
        return indentation.apply(
            toFirstLine: "public init(unboxer: Unboxer) throws {",
            nestedLines:      linesOfCodeInMethodBody(at:),
            andLastLine: "}")
    }

    private func linesOfCodeInMethodBody(at indentation: Indentation) -> [LineOfCode] {
        let linesOfCode = linesOfCodeForTransformations
        return linesOfCode.map(indentation.apply(toLineOfCode:))
    }

    private var linesOfCodeForTransformations: [LineOfCode] {
        let requiredTransformationLines = sortedRequiredTransformations.map { $0.requiredUnboxStatement }
        let optionalTransformationLines = sortedOptionalTransformations.map { $0.optionalUnboxStatement }
        return (requiredTransformationLines + optionalTransformationLines)
    }

    private var sortedRequiredTransformations: [TransformationFromJSON] {
        return sort(transformations: requiredTransformations)
    }

    private var sortedOptionalTransformations: [TransformationFromJSON] {
        return sort(transformations: optionalTransformations)
    }

    private func sort(transformations: [TransformationFromJSON]) -> [TransformationFromJSON] {
        return transformations.sorted { (lhs, rhs) -> Bool in
            return lhs.propertyName.compare(rhs.propertyName) == .orderedAscending
        }
    }
}

// Internal for unit test access.
internal extension TransformationFromJSON {
    var requiredUnboxStatement: LineOfCode {
        return "self.\(propertyName) = try unboxer.unbox(key: \"\(attributeName)\")"
    }

    var optionalUnboxStatement: LineOfCode {
        return "self.\(propertyName) = unboxer.unbox(key: \"\(attributeName)\")"
    }
}

fileprivate extension SwiftPrimitiveValueType {
    var name: String {
        switch self {
        case .any:        return "Any"
        case .bool:       return "Bool"
        case .date:       return "Date"
        case .double:     return "Double"
        case .emptyArray: return "[Any?]"
        case .int:        return "Int"
        case .string:     return "String"
        case .url:        return "URL"
        }
    }
}
